I"‡<p>Quack is an unique data structure that combines the properties of both Stack and a Queue. The structure can be viewed as a list of items written from left to right.</p>

<p><strong>It lets you perform following three operations on the structure.</strong></p>

<ul>
  <li><em>push</em> - add an element on to the left side of the structure</li>
  <li><em>pop</em>  - remove an element from the left end of the structure</li>
  <li><em>pull</em> - remove an element from the right end of the structure</li>
</ul>

<p>The great thing about this data structure is that these operations can be elegantly implemented using three stacks (or lists in Python), performing at amortized O(1)time. Here we are going to look at the implementation technique in Python.</p>

<p>Letâ€™s declare a class for Quack in Python. The key thing to note here is <em>total</em> variable. This will let us keep track of elements present in the structure.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">Quack</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">arr1</span> <span class="p">:</span> <span class="nb">list</span>
    <span class="n">arr2</span> <span class="p">:</span> <span class="nb">list</span>
    <span class="n">arr3</span> <span class="p">:</span> <span class="nb">list</span>
    <span class="n">total</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div></div>

<p>When we do a push operation, we append to both <em>arr1</em> and <em>arr2</em>. Then, increment the <em>total</em> by 1.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arr1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arr2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>When we do a pop operation, we first check if <em>total</em> is 0. If so, we clear both <em>arr1</em> and <em>arr3</em> and raise Exception.
Otherwise, move on to pop an element from <em>arr2</em> if non empty; decrement the <em>total</em> and return popped element from <em>arr1</em></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">total</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr1</span><span class="p">[:]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr3</span><span class="p">[:]</span>
            <span class="k">raise</span> <span class="nb">Exception</span><span class="p">(</span><span class="s">"Nothing to pop"</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arr2</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr1</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</code></pre></div></div>

<p>When we do a pull operation, we first check if <em>total</em> is 0. If so, we clear both <em>arr1</em> and <em>arr3</em> and raise Exception.
Otherwise, move on to check if <em>arr3</em> is empty, If so, recursively pop and append contents of <em>arr2</em> to <em>arr3</em>; ; decrement the <em>total</em> and return popped element from <em>arr3</em></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">pull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">total</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr1</span><span class="p">[:]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr3</span><span class="p">[:]</span>
            <span class="k">raise</span> <span class="nb">Exception</span><span class="p">(</span><span class="s">"Nothing to pull"</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arr3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arr3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arr2</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr3</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</code></pre></div></div>

<p><strong>Space/Runtime complexity:</strong></p>

<ul>
  <li>Space complexity is O(N) because for each element that is pushed, we store an extra copy in <em>arr2</em>.</li>
  <li>Time: <em>push</em> is O(1); For <em>pop</em> as long as <em>total</em> is not 0, <em>arr1</em> is never empty. When <em>total</em>  is 0, we need to clear both <em>arr1</em> and <em>arr3</em>, which takes O(N) time. This only happens following N pop or pull operations. So, pop has amortized O(1) time; <em>pull</em> is similar to pop when it comes to total being zero. In addition to this, it takes another O(N) time to pop and append contents from <em>arr2</em> to <em>arr3</em>. So, pull also has amortized O(1) time.</li>
</ul>
:ET