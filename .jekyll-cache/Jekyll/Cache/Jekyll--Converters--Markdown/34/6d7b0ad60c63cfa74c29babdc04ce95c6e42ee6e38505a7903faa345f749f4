I"Å<p>I like seeing elegant algorithms arise out of prodigious mathematical methods. One such is calculating day of any date in O(1).
Let‚Äôs take a look at the implementation.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">getDay</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">date</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">date</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="o">=</span><span class="n">date</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span> <span class="o">=</span> <span class="n">date</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span> <span class="n">vy</span> <span class="o">=</span> <span class="p">{</span><span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>
    <span class="n">y</span> <span class="o">-=</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">y</span><span class="o">/</span><span class="mi">4</span> <span class="o">-</span> <span class="n">y</span><span class="o">/</span><span class="mi">100</span> <span class="o">+</span> <span class="n">y</span><span class="o">/</span><span class="mi">400</span> <span class="o">+</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="kt">float</span><span class="p">(</span><span class="n">vy</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="mf">2.6</span><span class="o">-</span><span class="mf">0.2</span><span class="p">)</span> <span class="o">+</span> <span class="n">d</span><span class="p">);</span>
    <span class="n">r</span> <span class="o">%=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The variable <em>vy</em> here represents month index of a year. But, that‚Äôs weird, why are we assuming January as 11th month and March as 1st month? and why are we subtracting 1 from year if original month provided is less than 3. The reason is interesting which we will get into  towards the end.</p>

<p>First, we get into the meat of the formula where we adjust for the leap year. Explanation behind this part <strong>y/4 - y/100 + y/400</strong> is fairly simple.</p>

<ul>
  <li><em>Divisible by 4</em> ‚Äì&gt; then Leap Year, add 1</li>
  <li><em>Divisible by 100</em>, subtract 1 as its non-leap</li>
  <li>Unless <em>Divisible by 400</em>, add 1 as its leap year</li>
</ul>

<p>Before we dig into rest of the formula, lets clarify what our function returns. Our function is goint to be returning integer ranging from 0-6 where 0 denotes Sunday &amp; 6 is Saturday. <a href="https://www.timeanddate.com/calendar/?year=1&amp;country=22">Year Y=1</a> in Gregorian calendar <em>(Year Y=0 doesn‚Äôt exist)</em>. Given any year, the same date next year will be the next day (<em>365%7 = 1</em>), unless the given year/next year is a leap year, in which case it shifts two days or one day depending on whether date falling in January/February or March to December. In order to avoid this complexity, if we consider March to be the start of the year, January &amp; February to be the last two months of previous year, we can always add 1 to the end if its given year/previous year is leap year. As we set the concept of <strong>Virtual Year</strong> clear, now, all it comes down to is</p>

<ul>
  <li>subtracting 1 if month is Jan/Feb</li>
  <li>adding 1 if year obtained after previous step is leap</li>
</ul>

<p>And finally, what is the mystery <strong>vy[m-1])*2.6-0.2</strong>?  This is where we do projections. Our first month (March) in the 1st Virual Year falls on Thursday, The previous year Year 0 which didn‚Äôt exist is a hypothetical leap year consiting of 366 days. The first day of the first month (March) in the 1st Virual Year is Thursday. By rewinding 366 days back it is Tuesday (2). When we do this for all the first days of all the months in the 1st Virual Year, we get the following sequence.</p>

<ul>
  <li>{0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4}</li>
</ul>

<p>So, essentially we get the above sequence of days, which incidentically equals to floor(2.6*{11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} - 0.2).</p>

<p><em>Keep Calm and Start Coding</em></p>

:ET